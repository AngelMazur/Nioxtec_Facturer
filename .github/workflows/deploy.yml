name: Deploy to Production (Windows Self‑Hosted)

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch: {}

concurrency:
  group: deploy-production
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  deploy:
    env:
      APP_VERSION: ${{ github.ref_name }}
    runs-on:
      - self-hosted
      - windows
      - nioxtec
    timeout-minutes: 30
    steps:
      - name: Preflight – PowerShell policy
        shell: powershell
        run: |
          Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass -Force

      - name: Despliegue vía tarea programada (fallback a script)
        shell: powershell
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        run: |
          # Intentar ejecutar tarea si existe; si falla por permisos o inexistente, ejecutar script directo
          cmd.exe /c 'schtasks /Query /TN "Nioxtec Deploy CI" >NUL 2>&1'
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Tarea encontrada: ejecutando 'Nioxtec Deploy CI'"
            cmd.exe /c 'schtasks /Run /TN "Nioxtec Deploy CI"'
          } else {
            Write-Host "Tarea no disponible o acceso denegado: ejecutando script directo (inline)"
            $ErrorActionPreference = 'Continue'
            function Log([string]$m){ Write-Host ("[{0}] {1}" -f (Get-Date -Format 'yyyy-MM-dd HH:mm:ss'), $m) }
            $backendStopped = $false
            $frontendStopped = $false
            # 1) Build primero; no paramos servicios aún para no cortar producción
            try {
              Log 'Actualizando código backend con DEPLOY_TOKEN'
              Set-Location 'C:\Nioxtec\Nioxtec_Facturer'
              git config --global --add safe.directory 'C:/Nioxtec/Nioxtec_Facturer'
              $repoUrl = "https://x-access-token:$env:DEPLOY_TOKEN@github.com/AngelMazur/Nioxtec_Facturer.git"
              git remote set-url origin $repoUrl
              git fetch origin main --prune
              git reset --hard origin/main
              # Parar backend antes de tocar el venv para evitar ficheros .pyd bloqueados por el proceso en Windows
              try { Log 'Deteniendo backend para actualizar dependencias'; schtasks /End /TN "Nioxtec Backend" 2>$null | Out-Null; $backendStopped=$true } catch {}
              # Limpiar venvs versionados o previos
              try { Remove-Item -Recurse -Force '.\\.venv' -ErrorAction SilentlyContinue } catch {}
              try { Remove-Item -Recurse -Force '.\\.venv310' -ErrorAction SilentlyContinue } catch {}
              # Validar/recrear venv (crea un venv NUEVO por despliegue para evitar bloqueos por .pyd)
              try {
                # Crear un venv NUEVO por despliegue (evita bloqueos de .pyd en Windows)
                $ts = Get-Date -Format yyyyMMddHHmmss
                $venvDir = ".\\.venv_" + $ts
                $venvPy  = Join-Path $venvDir 'Scripts\\python.exe'
                $recreate = $true
                if (Test-Path $venvPy) {
                  try {
                    & $venvPy -c "import sys; print(sys.version)" 2>$null | Out-Null
                    if ($LASTEXITCODE -eq 0) { $recreate = $false } else { $recreate = $true }
                  } catch { $recreate = $true }
                }

                if ($recreate) {
                  try { Remove-Item -Recurse -Force $venvDir -ErrorAction SilentlyContinue } catch {}
                  # Detectar Python instalable
                  $pyExe = $null
                  $candidates = @(
                    'C:\\Program Files\\Python313\\python.exe',
                    'C:\\Program Files\\Python312\\python.exe',
                    'C:\\Program Files\\Python311\\python.exe',
                    "$env:LOCALAPPDATA\\Programs\\Python\\Python313\\python.exe",
                    "$env:LOCALAPPDATA\\Programs\\Python\\Python312\\python.exe",
                    "$env:LOCALAPPDATA\\Programs\\Python\\Python311\\python.exe",
                    'C:\\Python313\\python.exe',
                    'C:\\Python312\\python.exe',
                    'C:\\Python311\\python.exe'
                  )
                  foreach ($p in $candidates) { if (Test-Path $p) { $pyExe = $p; break } }
                  if (-not $pyExe) {
                    try { $cmd = Get-Command python -ErrorAction SilentlyContinue; if ($cmd) { $pyExe = $cmd.Source } } catch {}
                  }
                  if (-not $pyExe) {
                    try { $cmd = Get-Command py -ErrorAction SilentlyContinue; if ($cmd) { $pyExe = 'py' } } catch {}
                  }

                  $created = $false
                  if ($pyExe -eq 'py') {
                    try { py -3.11 -m venv $venvDir 2>$null } catch {}
                    $created = Test-Path $venvPy
                    if (-not $created) { try { py -3 -m venv $venvDir 2>$null } catch {}; $created = Test-Path $venvPy }
                  } elseif ($pyExe) {
                    & $pyExe -m venv $venvDir 2>$null
                    $created = Test-Path $venvPy
                  }
                  if (-not $created) { throw 'No se pudo crear venv: no se encontró Python' }
                }

                $venvOk = $false
                if (Test-Path $venvPy) {
                  try {
                    & $venvPy -c "import sys; print(sys.version)" 2>$null | Out-Null
                    if ($LASTEXITCODE -eq 0) { $venvOk = $true } else { $venvOk = $false }
                  } catch { $venvOk = $false }
                }
                if ($venvOk) {
                  try { & $venvPy -m ensurepip --upgrade 2>$null | Out-Null } catch {}
                  & $venvPy -m pip install --upgrade pip
                  & $venvPy -m pip install --upgrade --no-input -r requirements.txt
                  try { $venvAbs = (Resolve-Path $venvDir).Path } catch { $venvAbs = $venvDir }
                } else {
                  Log 'Aviso: venv no disponible aún; se intentará instalar Python en la fase de Alembic'
                }
              } catch { Log "Backend deps error: $($_.Exception.Message)" }

              # Backup de base de datos (SQLite local y/o PostgreSQL si DATABASE_URL está presente)
              try {
                $timestamp = Get-Date -Format yyyyMMddHHmmss
                $backupRoot = 'C:\Nioxtec\backups\facturer'
                New-Item -ItemType Directory -Force -Path $backupRoot | Out-Null
                $sqliteDb = 'C:\Nioxtec\Nioxtec_Facturer\instance\app.db'
                if (Test-Path $sqliteDb) {
                  Copy-Item $sqliteDb (Join-Path $backupRoot ("app_" + $timestamp + '.db')) -Force
                  Log "Backup SQLite creado"
                }
                if ($env:DATABASE_URL -and $env:DATABASE_URL.StartsWith('postgres')) {
                  $pgDump = 'C:\Program Files\PostgreSQL\16\bin\pg_dump.exe'
                  if (-not (Test-Path $pgDump)) { $pgDump = 'C:\Program Files\PostgreSQL\15\bin\pg_dump.exe' }
                  if (Test-Path $pgDump) {
                    & $pgDump --file (Join-Path $backupRoot ("backup_" + $timestamp + '.dump')) --format=c $env:DATABASE_URL
                    Log 'Backup PostgreSQL creado'
                  } else {
                    Log 'pg_dump no encontrado; omitido backup PostgreSQL'
                  }
                }
              } catch { Log "Error en backup DB: $($_.Exception.Message)" }

              # Migraciones Alembic
              try {
                $venvOk = $false
                if (Test-Path $venvPy) {
                  try { & $venvPy -c "import sys; print(sys.version)" 2>$null | Out-Null; $venvOk = $true } catch { $venvOk = $false }
                }
                if (-not $venvOk) {
                  Log 'Venv inexistente o inválido; intento de crear uno con winget (Python 3.11)'
                  try {
                    $winget = Get-Command winget -ErrorAction SilentlyContinue
                    if ($winget) {
                      winget install --id Python.Python.3.11 -e --silent --accept-package-agreements --accept-source-agreements
                    } else {
                      Log 'winget no disponible; intentando instalador oficial de python.org'
                      $pyUrl = 'https://www.python.org/ftp/python/3.11.9/python-3.11.9-amd64.exe'
                      $installer = Join-Path $env:TEMP 'python311.exe'
                      try { Invoke-WebRequest -Uri $pyUrl -UseBasicParsing -OutFile $installer } catch {}
                      if (Test-Path $installer) {
                        Start-Process -FilePath $installer -ArgumentList '/quiet InstallAllUsers=1 PrependPath=1 Include_pip=1' -Wait
                      } else { Log 'No se pudo descargar instalador de Python. Revise conectividad.' }
                    }
                    $py = Get-Command python -ErrorAction SilentlyContinue
                    if ($py) { & $py.Source -m venv $venvDir 2>$null }
                    if (Test-Path $venvPy) {
                      try { & $venvPy -m ensurepip --upgrade 2>$null | Out-Null } catch {}
                      & $venvPy -m pip install --upgrade pip
                      & $venvPy -m pip install --upgrade --no-input -r requirements.txt
                      $venvOk = $true
                      try { $venvAbs = (Resolve-Path $venvDir).Path } catch { $venvAbs = $venvDir }
                    }
                  } catch { Log "No fue posible instalar Python automáticamente: $($_.Exception.Message)" }
                }
                if ($venvOk) {
                  # Asegurar dependencias antes de ejecutar Alembic
                  try {
                    & $venvPy -m ensurepip --upgrade 2>$null | Out-Null
                    & $venvPy -m pip --version 2>$null | Out-Null
                    & $venvPy -m pip install --upgrade pip 2>$null | Out-Null
                    & $venvPy -m pip install --upgrade --no-input -r requirements.txt 2>$null | Out-Null
                  } catch { Log 'Aviso: no se pudieron instalar dependencias antes de Alembic' }

                  $hasAlembic = $false
                  try { & $venvPy -c "import alembic" 2>$null | Out-Null; $hasAlembic = $true } catch { $hasAlembic = $false }
                  if (-not $hasAlembic) {
                    try { & $venvPy -m pip install alembic 2>$null | Out-Null; $hasAlembic = $true } catch { $hasAlembic = $false }
                  }

                  if ($hasAlembic) {
                    Log 'Ejecutando migraciones Alembic (upgrade head)'
                    & $venvPy -m alembic upgrade head
                    if ($LASTEXITCODE -ne 0) { throw "Alembic upgrade devolvió código $LASTEXITCODE" }
                  } else {
                    Log 'Alembic no disponible; omitiendo migraciones (sin cambios de esquema críticos)'
                  }
                } else {
                  Log 'Omitiendo migraciones: no hay intérprete Python funcional. (Fase 2 sin cambios de esquema)'
                }
              } catch {
                Write-Error "Alembic upgrade falló: $($_.Exception.Message)"; exit 1
              }
            } catch { Log "Backend update error: $($_.Exception.Message)" }
            try {
              Log 'npm ci && build frontend'
              Set-Location 'C:\Nioxtec\Nioxtec_Facturer\frontend'
              npm ci
              $env:VITE_API_BASE = 'https://api.nioxtec.es'
              npm run build
            } catch { Log "Frontend build error: $($_.Exception.Message)" }

            # Escribir APP_VERSION, APP_ORIGIN y VENV_DIR en .env para que la app lo lea al arrancar
            try {
              Set-Location 'C:\Nioxtec\Nioxtec_Facturer'
              $envFile = 'C:\Nioxtec\Nioxtec_Facturer\.env'
              if (Test-Path $envFile) {
                (Get-Content $envFile | Where-Object { $_ -notmatch '^APP_VERSION=' -and $_ -notmatch '^APP_ORIGIN=' -and $_ -notmatch '^VENV_DIR=' }) | Set-Content $envFile -Encoding UTF8
              }
              Add-Content -Path $envFile -Value ("APP_VERSION=" + $env:APP_VERSION)
              Add-Content -Path $envFile -Value ("APP_ORIGIN=https://app.nioxtec.es")
              if ($null -ne $venvAbs -and $venvAbs -ne '') {
                Add-Content -Path $envFile -Value ("VENV_DIR=" + $venvAbs)
              } else {
                try { $absVenv = (Resolve-Path $venvDir).Path } catch { $absVenv = $venvDir }
                Add-Content -Path $envFile -Value ("VENV_DIR=" + $absVenv)
              }
              Log (".env actualizado con APP_VERSION=" + $env:APP_VERSION)
            } catch { Log "No se pudo actualizar .env con APP_VERSION: $($_.Exception.Message)" }
            # 2) Reiniciar servicios tras migración
            try { Log 'Reiniciando backend'; schtasks /End /TN "Nioxtec Backend" 2>$null | Out-Null; $backendStopped=$true } catch {}
            try { Log 'Reiniciando frontend'; schtasks /End /TN "Nioxtec Frontend" 2>$null | Out-Null; $frontendStopped=$true } catch {}
            try { Log 'Reiniciando Cloudflare Tunnel'; schtasks /End /TN "Cloudflared Tunnel" 2>$null | Out-Null } catch {}
            try { if ($backendStopped) { schtasks /Run /TN "Nioxtec Backend" 2>$null | Out-Null; Log 'Backend arrancado' } } catch {}
            try { if ($frontendStopped) { schtasks /Run /TN "Nioxtec Frontend" 2>$null | Out-Null; Log 'Frontend arrancado' } } catch {}
            try { schtasks /Run /TN "Cloudflared Tunnel" 2>$null | Out-Null; Log 'Cloudflare arrancado' } catch {}
            # 3) Asegurar que los servicios están arrancados
            Start-Sleep -Seconds 3
            try { schtasks /Run /TN "Nioxtec Backend" 2>$null | Out-Null; Log 'Backend asegurado' } catch {}
            try { schtasks /Run /TN "Nioxtec Frontend" 2>$null | Out-Null; Log 'Frontend asegurado' } catch {}
            try { schtasks /Run /TN "Cloudflared Tunnel" 2>$null | Out-Null; Log 'Cloudflare asegurado' } catch {}
            # 4) Verificar rutas nuevas (robusto a 502 de túnel/CDN)
            try {
              # Esperar a que la salud pública sea 200 antes de pruebas de preflight
              Log 'Esperando health pública antes de preflight rutas...'
              $publicOk = $false
              for ($i=1; $i -le 18; $i++) {
                try {
                  $resp = Invoke-WebRequest https://api.nioxtec.es/health -UseBasicParsing -TimeoutSec 15
                  Write-Host ("Health público intento ${i}: " + $resp.StatusCode)
                  if ($resp.StatusCode -eq 200) { $publicOk = $true; break }
                } catch { Write-Host ("Health público intento ${i}: no disponible") }
                Start-Sleep -Seconds 10
              }

              if (-not $publicOk) {
                # Si la API local está viva, tolerar 502/propagación y no bloquear deploy aquí
                $localOk = $false
                try { $local = Invoke-WebRequest http://localhost:8000/health -UseBasicParsing -TimeoutSec 10; if ($local.StatusCode -eq 200) { $localOk = $true } } catch {}
                if ($localOk) {
                  Log 'AVISO: Saltando verificación de rutas públicas por 502/propagación; API local OK'
                  $global:LASTEXITCODE = 0
                  return
                } else {
                  throw 'Health público no 200 y API local no responde en 8000'
                }
              }

              # Preflight CORS sobre rutas nuevas con algunos reintentos por si tarda en alzarse
              $h = @{ Origin='https://app.nioxtec.es'; 'Access-Control-Request-Method'='GET'; 'Access-Control-Request-Headers'='authorization,content-type' }
              $ok1 = $false; $ok2 = $false
              for ($j=1; $j -le 6; $j++) {
                try { $opt1 = Invoke-WebRequest https://api.nioxtec.es/api/clients/1/invoices -Method OPTIONS -UseBasicParsing -Headers $h -TimeoutSec 15; if ($opt1.StatusCode -ne 404) { $ok1 = $true } } catch {}
                try { $opt2 = Invoke-WebRequest https://api.nioxtec.es/api/clients/1/documents -Method OPTIONS -UseBasicParsing -Headers $h -TimeoutSec 15; if ($opt2.StatusCode -ne 404) { $ok2 = $true } } catch {}
                if ($ok1 -and $ok2) { break }
                Start-Sleep -Seconds 5
              }
              if (-not $ok1) { throw 'Ruta /api/clients/:id/invoices no disponible tras deploy' }
              if (-not $ok2) { throw 'Ruta /api/clients/:id/documents no disponible tras deploy' }
              Log 'Rutas nuevas verificadas'
              $global:LASTEXITCODE = 0
            } catch { Write-Error $_.Exception.Message; exit 1 }

          }

      - name: Verificación final (salud pública con reintentos)
        shell: powershell
        run: |
          Write-Host "Verificando API local..."
          $localOk = $false
          try {
            $local = Invoke-WebRequest http://localhost:8000/health -UseBasicParsing -TimeoutSec 10
            Write-Host ("API local: " + $local.StatusCode)
            if ($local.StatusCode -eq 200) { $localOk = $true }
          } catch { Write-Host 'Aviso: API local no verificada' }

          Write-Host "Verificando API publica con reintentos..."
          $ok = $false
          for ($i=1; $i -le 18; $i++) {
            try {
              $resp = Invoke-WebRequest https://api.nioxtec.es/health -UseBasicParsing -TimeoutSec 15
              Write-Host ("Intento ${i}: " + $resp.StatusCode)
              if ($resp.StatusCode -eq 200) { $ok = $true; break }
            } catch {
              Write-Host ("Intento ${i}: no disponible")
            }
            Start-Sleep -Seconds 10
          }

          if ($ok) {
            Write-Host "DEPLOY EXITOSO"
            exit 0
          }

          if ($localOk) {
            Write-Host "AVISO: API publica no 200 tras reintentos, pero API local OK. Puede ser propagacion/CDN."
            # No bloquear el pipeline en este caso puntual
            exit 0
          }

          Write-Error "API publica no disponible tras reintentos"
          exit 1
